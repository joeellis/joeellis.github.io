<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width initial-scale=1"> <title>Redux Architecture Guidelines | joeellis.la</title> <meta property="og:title" content="Redux Architecture Guidelines"/> <meta name="author" content="Joe Ellis"/> <meta property="og:locale" content="en_US"/> <meta name="description" content="Describing patterns I use when building Redux apps."/> <meta property="og:description" content="Describing patterns I use when building Redux apps."/> <link rel="canonical" href="http://joeellis.la/redux-architecture/"/> <meta property="og:url" content="http://joeellis.la/redux-architecture/"/> <meta property="og:site_name" content="joeellis.la"/> <meta property="og:type" content="article"/> <meta property="article:published_time" content="2017-06-20T00:00:00-05:00"/> <meta name="twitter:card" content="summary"/> <meta name="twitter:site" content="@notjoellis"/> <meta name="twitter:creator" content="@Joe Ellis"/> <script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"Redux Architecture Guidelines","author":{"@type":"Person","name":"Joe Ellis"},"datePublished":"2017-06-20T00:00:00-05:00","dateModified":"2017-06-20T00:00:00-05:00","description":"Describing patterns I use when building Redux apps.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://joeellis.la/assets/images/avatar.png"},"name":"Joe Ellis"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://joeellis.la/redux-architecture/"},"url":"http://joeellis.la/redux-architecture/"}</script> <link rel="stylesheet" href="/css/main.css"> <link rel="alternate" type="application/atom+xml" title="joeellis.la" href="http://joeellis.la/feed.xml"/> <link rel="canonical" href="http://joeellis.la/redux-architecture/"> <link href="https://fonts.googleapis.com/css?family=Droid+Serif|PT+Sans" rel="stylesheet"> <meta content="Describing patterns I use when building Redux apps." property="description"> <meta property="og:image" content="http://joeellis.la/assets/images/avatar.png"> <meta property="article:tag" content="react"> <meta property="article:tag" content="redux"> <meta name="twitter:title" content="Redux Architecture Guidelines"> <meta name="twitter:description" content="Describing patterns I use when building Redux apps."> <meta name="twitter:image" content="http://joeellis.la/assets/images/avatar.png"> </head> <body> <div class="site-container"> <div class="wrapper"> <a class="rss-link" href="/feed.xml"> <i class="fa fa-rss" aria-hidden="true"></i> </a> <div class="page-content"> <div class="header-intro"> <div class="intro-details"> <div class="intro-photo"> <a href="http://joeellis.la"> <img class="avatar-photo" src="/assets/images/avatar.png" width="55" height="55"/> </a> </div> <p class="intro-description"> <a href="http://joeellis.la">My name is Joe Ellis and I am a full stack developer in New Orleans, interested all things Elixir, Ruby, and Javascript.</a> </p> </div> </div> <hr/> <div class="post"> <header class="post-header"> <h1 class="post-title">Redux Architecture Guidelines</h1> <p class="post-meta">June 20, 2017</p> </header> <article class="post-content"> <p>I’ve written many Redux apps over the past couple of years, and it is by far my favorite JS framework. The only downside is, unlike other frameworks, Redux is far less opinionated in how to structure an app. I prefer this freedom, but it does make for a steeper learning curve, especially if you’re new to Redux. So I decided to write up some of the higher level thinking and structure I’ve picked up and often use when building a Redux app. Hopefully it comes in handy for someone out there.</p> <h3 id="state">State</h3> <h5 id="plan-your-state-shape">Plan your state shape</h5> <p>In terms of saving time down the road, planning the structure of your state object upfront is most valuable thing you can do for your app. A poorly formed state object will make your app difficult to maintain and is avoidable with some planning. I run through this quick checklist when planning out state objects:</p> <ul> <li>How will it store multiple resources from an API (users, accounts, items, etc)?</li> <li>How will it handle loading states (showing loading spinners when fetching /updating data)?</li> <li>How will it handle showing and clearing of UI success and error notifications?</li> <li>Does it feel consistent and predictable? Could another team member easily work with it?</li> <li>Is it easy to access data within it? Does it nest properties unnecessarily?</li> <li>Is it serializable? Could it easily be stored away in localstorage or in a database?</li> <li>Are there any properties you could pull from the URL instead of in the state?</li> <li>Is there any duplicated data in here? If so, is that really needed?</li> </ul> <p>There are <strong>many</strong> different ways to answer these questions - it depends on your app. But in my experience, having at least an answer for each will save you time in the long run.</p> <h5 id="avoid-nesting-state-objects">Avoid nesting state objects</h5> <p>Some Redux apps have deeply nested state structures, i.e. shapes that look like this:</p> <figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">bar</span><span class="p">:</span> <span class="p">{</span>
      <span class="nl">baz</span><span class="p">:</span> <span class="p">{</span>
        <span class="nl">qux</span><span class="p">:</span> <span class="p">...</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>This often happens when we work with relational data as it feels natural to use nesting to represent those relationships. Unfortunately, nested data structures create complexity. At the component level, you’ll have to reach even deeper into the state to get certain information. And at the reducer level, merging new data into your state will become far more complex. On top of all of that, nested data can even cause performance issues with React / Redux itself.</p> <p>Consider instead to flatten and <a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html">normalize</a> your state shape. In Redux land, the shallower the nesting, the easier it is is to fetch and update state data in your app. Normalized states help solve the problems listed above, and make your state much more flexible overall.</p> <h5 id="storing-only-raw-data-in-the-state">Storing only raw data in the state</h5> <p>It’s tempting to use Redux’s state as a vehicle to store any and all information you think you may need later. Yet, doing so will increase your app’s complexity in the form of state bloat and redundant properties. This, in turn, increases complexity in your actions, reducers, and tests. So what should and shouldn’t be stored?</p> <p>In Redux apps, there are really two types of data. The first is raw data, data your app requires to run. User data fetched from an API is an example of raw data - without it, your app won’t have the information it needs to run. The second is derived data, or data created from other existing data. Using the <code class="highlighter-rouge">firstName</code> and <code class="highlighter-rouge">lastName</code> properties to display a user’s name as <code class="highlighter-rouge">Jane Doe</code> is an example of derived data.</p> <p>I recommend persisting <strong>only</strong> raw data in your state. It helps reduces state bloat and makes it easier to reason about what data is important in your app. All other derived data should be created using functions that accept that raw data from the state return back the information you need.</p> <p>Before adding something new to the state object, ask yourself this question, “Can I create this from data that already exists in the state?” If the answer is “yes”, then create that data with a function. If the answer is “no”, then you may have a good case to add this data to the state. You may be surprised over time how often the answer is “yes.”</p> <h5 id="prefer-redux-state-over-react-state">Prefer Redux state over React state</h5> <p>React comes with <a href="https://facebook.github.io/react/docs/react-component.html#state">its own system for managing state</a> inside of components. In a Redux app, though, prefer to use Redux’s state for the majority of your app data and inter-component communication. It is overall much easier to reason about your app when there is one accepted way for components to set and access state, especially if you are working within a team.</p> <p>Note that there are reasonable exceptions to this guideline. It can be beneficial for complex UI components to persist local properties using React component state, especially when those properties aren’t globally important to the app. When doing this, just try to keep that React state management localized to that component. Using two separate state systems too much, especially for inter-component communication, is likely to cause confusion for the developer after you.</p> <h3 id="actions">Actions</h3> <h5 id="standardize-action-payloads">Standardize action payloads</h5> <p>When working with a team, having a standard object shape for your actions is very helpful. Doing so reduces <a href="http://bikeshed.org/">bikeshedding</a> and creates maintainable and testable code. I highly recommend adopting some kind of standard with your team. I use the <a href="https://github.com/acdlite/flux-standard-action">Flux Standard Action spec</a> because it is straightforward and simple to understand. But whatever you use, make sure it’s consistent and easy to work with.</p> <h5 id="ensure-action-creators-are-composable">Ensure action creators are composable</h5> <p>Many example apps and tutorials I run across use simple action creator functions when teaching Redux concepts. This is great for illustrating a point, but real world apps are complex. It’s inevitable that you will need to compose higher-level complex actions, preferably from existing action creators you have already written.</p> <p>Start a habit of making sure all your action creator functions are composable in some way. It’s a simple rule that really pays off when you need it. I personally wrap each action creator in a <a href="https://github.com/then/promise">promise</a> so they can be easily chained together using the <code class="highlighter-rouge">then</code> function.</p> <h3 id="component-architecture">Component Architecture</h3> <h5 id="containers--presentational-components">Containers &amp; presentational components</h5> <p>The most useful concept I’ve come across for building stable and easily maintainable Redux apps is the <a href="http://redux.js.org/docs/basics/UsageWithReact.html#presentational-and-container-components">container &amp; presentational component</a> paradigm as described by Dan Abramov in the official Redux documentation. I will not dive into it here as the docs already do a great job at explaining the concept with great examples. But understanding this paradigm may be one of the most useful things you can learn about in Redux land. It is very difficult to maintain and iterate on an app of even moderate complexity without it. Learn it well.</p> <h5 id="use-intermediary-containers">Use intermediary containers</h5> <p>While the container / presentational component paradigm works, it’s not always clear when containers should be introduced. I’ve seen (and written) apps with a single top-level container that fetches the whole world and then passes down everything to its component’s children and their children’s children. This results in props ‘passing through’ multiple components before they are ever even used. As your app grows, this becomes an annoying problem as even simple changes, like renaming props, involves changing many other non-related components. Definitely a code smell that something is not right.</p> <p>Instead, create containers when you notice multiple props ‘passing through’ multiple components. There is no need to pass props from one end to the other when a container in the middle can access the state and create those props for you. Intermediary containers also have added benefits, such as encapsulating sections of your component tree making their children easier to maintain and test. Don’t be afraid to use them if the situation calls for it.</p> <h3 id="there-are-no-rules">There are No Rules</h3> <p>All the guidelines I’ve listed are just patterns I’ve found worth repeating. However, do not consider any these points as the <em>only</em> way to do things. After all, one of biggest advantages of Redux is its free form structure, so know when you should ‘break’ the rules and try something new.</p> </article> <hr> <div class="question"> <a class="twitter-follow-button" href="https://twitter.com/notjoeellis" data-show-count="true" data-size="large"> Follow @notjoeellis </a> <script type="text/javascript">window.twttr=function(t,e,r){var n,i,w=t.getElementsByTagName(e)[0];if(!t.getElementById(r))return i=t.createElement(e),i.id=r,i.src="https://platform.twitter.com/widgets.js",w.parentNode.insertBefore(i,w),window.twttr||(n={_e:[],ready:function(t){n._e.push(t)}})}(document,"script","twitter-wjs");</script> </div> </div> </div> <footer class="site-footer"> <p class="small">joeellis.la &copy; 2017</p> </footer> </div> </div> </body> <script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-99074897-1","auto"),ga("send","pageview");</script> </html>